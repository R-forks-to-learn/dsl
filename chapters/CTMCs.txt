# Continuous time Markov chains

We now turn to an example of a domain-specific language based on a combination of tidy evaluation and the `magrittr` pipe operator; we will write a language for specifying continuous time Markov chains (CTMCs) and for computing the likelihood of parameters in such CTMCs given a trace of which states the chain is in at different time points.

We will use the packages `magrittr` and `rlang` to construct the language 


```r
library(magrittr)
library(rlang)
```

and we will reuse the linked list code plus the functions `collect_symbols_rec` and `make_args_list` we implemented in previous chapters.

```{r, echo=FALSE}
cons <- function(car, cdr) list(car = car, cdr = cdr)
lst_length <- function(lst) {
  len <- 0
  while (!is.null(lst)) {
    lst <- lst$cdr
    len <- len + 1
  }
  len
}
lst_to_list <- function(lst) {
  v <- vector(mode = "list", length = lst_length(lst))
  index <- 1
  while (!is.null(lst)) {
    v[[index]] <- lst$car
    lst <- lst$cdr
    index <- index + 1
  }
  v
}

collect_symbols_rec <- function(expr, lst, bound) {
  if (is.symbol(expr) && expr != "") {
    if (as.character(expr) %in% bound) lst
    else cons(as.character(expr), lst)

  } else if (is.pairlist(expr)) {
    for (i in seq_along(expr)) {
      lst <- collect_symbols_rec(expr[[i]], lst, bound)
    }
    lst

  } else if (is.call(expr)) {
    if (expr[[1]] == as.symbol("function"))
      bound <- c(names(expr[[2]]), bound)

    for (i in 1:length(expr)) {
      lst <- collect_symbols_rec(expr[[i]], lst, bound)
    }
    lst

  } else {
    lst
  }
}

make_args_list <- function(args) {
  res <- replicate(length(args), substitute())
  names(res) <- args
  as.pairlist(res)
}
```

We will use these functions to construct functions from a CTMC specification by extracting the unbound symbols in expressions we associate with transition rates. We will not use the `collect_symbols` function we implemented to collect unbound variables but instead a version that expects its expression to be quoted already:

```{r}
collect_symbols_q <- function(expr, env) {
  bound <- c()
  lst <- collect_symbols_rec(expr, NULL, bound)
  lst %>% lst_to_list %>% unique %>%
    purrr::discard(exists, env) %>%
    unlist
}
```

This is because we plan to quote expressions in the DSL functions and then call this function with these quoted expressions.

## Constructing the Markov chain 

We explored several approaches to design a language for CTMCs in [Chapter @sec:components]. In this chapter, we will use the variation that uses the pipe operator, `%>%`, together with an `add_edge` function. We will collect edges in three lists: one list for the “from” states, one for the “to” states, and one for the rates associated with the transitions. In addition, we will collect the unbound variables in the rate expressions when we create new edges, so later changes to scopes will not affect the parameters of the CTMC model. To represent a CTMC, we create a class and a list that holds the “from”, “to”, rates and parameters lists:

```{r}
ctmc <- function()
  structure(list(from = NULL,
                 rate = NULL,
                 to = NULL,
                 params = NULL),
            class = "ctmc")
```

We want the syntax for constructing a CTMC to look like this:

```r
m <- ctmc() %>%
  add_edge(foo, a, bar) %>%
  add_edge(foo, 2*a, baz) %>%
  add_edge(foo, 4, qux) %>%
  add_edge(bar, b, baz) %>%
  add_edge(baz, a + x*b, qux) %>%
  add_edge(qux, a + UQ(x)*b, foo)
```

Therefore, we need to implement the `add_edge` such that it takes four arguments: the CTMC, the “from” state, the rate of the transition, and the “to” state. The CTMC is implicitly provided to the function calls when we are using the pipe operator. The other three arguments should be provided as expressions and the `add_edge` function will implement a non-standard evaluation to handle them.

We want the “from” and “to” states to be single symbols, but we will translate these into strings that we can use as row- and column-names in the rate matrix for the CTMC. The rate associated with a transition should be an expression, and to get the scope of the expression right, we will translate it into a quosure. We will then extract the unbound variables in this expression—unbound in the environment in which the quosure  is defined—and add these to the parameters of the model. The implementation looks like this:

```{r}
add_edge <- function(ctmc, from, rate, to) {
  from <- enexpr(from) ; stopifnot(is_symbol(from))
  to <- enexpr(to) ; stopifnot(is_symbol(to))
  
  from <- as_string(from)
  to <- as_string(to)
  
  ctmc$from <- cons(from, ctmc$from)
  ctmc$to <- cons(to, ctmc$to)

  r <- enquo(rate)
  ctmc$rate <- cons(r, ctmc$rate)
  ctmc$params <- cons(collect_symbols_q(UQE(r), get_env(r)), 
                       ctmc$params)

  ctmc
}
```

We use `enexpr` for `from` and `to` since we want these symbols to be just that, symbols, and not something we will want to evaluate in any context. We use `enquo` for the `rate` parameter, on the other hand, be cause we do want to have its environment available when we evaluate the expression. We do not evaluate it yet, though. We cannot evaluate it until we know the parameters for the model, and we do not want those to be fixed inside the CTMC object. We use the rate environment, however, when extracting the unbound variables in the rate expression.



```{r}
print.ctmc <- function(x, ...) {
  from <- lst_to_list(x$from) %>% rev
  to <- lst_to_list(x$to) %>% rev
  rate <- lst_to_list(x$rate) %>% rev
  parameters <- lst_to_list(x$params) %>% unlist %>% unique %>% rev

  cat("CTMC:\\n")
  cat("parameters:", paste(parameters), "\\n")
  cat("transitions:\\n")
  for (i in seq_along(from)) {
    cat(from[[i]], "->", to[[i]], "\\t[", deparse(UQE(rate[[i]])), "]\\n")
  }
  cat("\n")
}
```

```{r}
x <- 2
m <- ctmc() %>%
  add_edge(foo, a, bar) %>%
  add_edge(foo, 2*a, baz) %>%
  add_edge(foo, 4, qux) %>%
  add_edge(bar, b, baz) %>%
  add_edge(baz, a + x*b, qux) %>%
  add_edge(qux, a + UQ(x)*b, foo)
m
```

## Constructing a rate matrix

```{r}
rate_matrix_function <- function(ctmc) {
  from <- lst_to_list(ctmc$from) %>% rev
  to <- lst_to_list(ctmc$to) %>% rev
  rate <- lst_to_list(ctmc$rate) %>% rev

  nodes <- c(from, to) %>% unique %>% unlist
  parameters <- lst_to_list(ctmc$params) %>% unlist %>% unique %>% rev

  n <- length(nodes)

  f <- function() {
    Q <- matrix(0, nrow = n, ncol = n)
    rownames(Q) <- colnames(Q) <- nodes
    for (i in seq_along(from)) {
      Q[from[[i]], to[[i]]] <- eval_tidy(rate[[i]], environment())
    }
    diag(Q) <- -rowSums(Q)
    Q
  }
  formals(f) <- make_args_list(parameters)

  f
}

Q <- m %>% rate_matrix_function
Q
Q(a = 2, b = 4)

x <- 1
Q(a = 2, b = 4)
```

## Traces

```{r}
ctmc_trace <- function(ctmc) {
  nodes <- c(lst_to_list(ctmc$from), lst_to_list(ctmc$to)) %>%
    unique %>% unlist
  structure(list(nodes=nodes, states=NULL, at=NULL),
            class="ctmc_trace")
}
start_state <- function(trace, state, at=0) {
  state <- enexpr(state)
  stopifnot(is_symbol(state))
  state <- as_string(state)
  stopifnot(state %in% trace$nodes)
  stopifnot(is.numeric(at))

  trace$states <- cons(state, trace$states)
  trace$at <- cons(at, trace$at)

  trace
}
transition <- function(trace, at, to) {
  stopifnot(is.numeric(at))
  to <- enexpr(to)
  stopifnot(is_symbol(to))
  to <- as_string(to)
  stopifnot(to %in% trace$nodes)

  trace$states <- cons(to, trace$states)
  trace$at <- cons(at, trace$at)

  trace
}

print.ctmc_trace <- function(x, ...) {
  states <- x$states %>% lst_to_list %>% unlist %>% rev
  at <- x$at %>% lst_to_list %>% unlist %>% rev
  df <- tibble::tibble(state = states, at = at)
  print(df)
}

tr <- ctmc_trace(m) %>%
  start_state(foo) %>%
  transition(0.1, bar) %>%
  transition(0.3, baz) %>% 
  transition(0.5, qux) %>%
  transition(0.7, foo) %>%
  transition(1.1, baz)
tr
```

## Computing likelihoods

```{r, echo=FALSE}
suppressPackageStartupMessages(library(expm, quietly = TRUE))
```
```r
library(expm)
```
```{r}
transition_probabilities <- function(Q, t) expm(Q * t)
```

```{r}
likelihood_function <- function(ctmc, trace) {
  rate_func <- ctmc %>% rate_matrix_function
  trace_df <- tibble::as_tibble(trace)
  
  lhd_function <- function() {
    args <- as_list(environment())
    Q <- do.call(rate_func, args)
    
    n <- length(trace_df$state)
    from <- trace_df$state[-n]
    to <- trace_df$state[-1]
    delta_t <- trace_df$at[-1] - trace_df$at[-n]
    
    lhd <- 1
    for (i in seq_along(from)) {
      P <- transition_probabilities(Q, delta_t[i])
      lhd <- lhd * P[from[i],to[i]]
    }
    lhd
  }
  formals(lhd_function) <- formals(rate_func)
  
  lhd_function
}

lhd <- m %>% likelihood_function(tr)
lhd(a = 2, b = 4)
```

