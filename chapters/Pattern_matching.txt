# Pattern matching

In languages such as ML or Haskell, you can define data types by specifying functions you will use to construct values of any given type. In itself, that is not that interesting, but combined with a pattern matching feature of these languages, you can write very succinct functions for transforming data structures.

In my book on *Functional Data Structures in R* [@Mailund:2017ul], I describe several algorithms that depend on transformation of various trees based on their structure. This involves figuring out the current structure of a tree—does it have a left sub-tree? Is that tree a leaf? If it is a red-black search tree, what is the colour of the tree? And the colour of its right sub-tree? In the algorithms I presented in that book, most of the functions contained tens of lines of code just for matching such tree structure.

With the language we implement in this chapter, we will make writing such transformation functions vastly more efficient. We will write two main constructions. The first for defining a data structure, which we can use to define red-black search trees like this:

```r
colour := R | B
rb_tree := E | T(col : colour, left : rb_tree, value, right : rb_tree)
```

The second constructing is used to match values of such types and then perform actions accordingly. A balancing function for red-black search trees can be succinctly implemented like this:

```r
balance <- function(tree) {
  match(tree,
        T(B,T(R,a,x,T(R,b,y,c)),z,d) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,T(R,T(R,a,x,b),y,c),z,d) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,a,x,T(R,b,y,T(R,c,z,d))) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,a,x,T(R,T(R,b,y,c),z,d)) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        otherwise -> tree)
}
```

This function is mere eight lines, compared to the 42 lines of code used in *Functional Data Structures in R*, where I also use some pattern matching tricks but not a domain-specific language especially designed for it. Such a language is what we will implement in this chapter.

For the chapter, we need to will use the following packages:

```r
library(rlang)
library(magrittr)
library(dplyr)
```

We will also need the `make_args_list` function we defined in [Chapter @sec:lambda].

```{r}
make_args_list <- function(args) {
  res <- replicate(length(args), substitute())
  names(res) <- args
  as.pairlist(res)
}
```

## Constructors

The first construction we must implement is for defining data types. Here, we will use the `:=` operator. Assignment has the lowest precedence, which means that whatever we write to the left or right of this operator will be arguments to the function. We do not have to worry about an expression in our language being translated into some `call` object of a different type. We cannot override the other assignment operators, `<-`, `->` and `=`, so we have to use `:=`. Since this is also traditionally used to mean “defined to be equal to”, it works quite well.

The approach we take in implementing this part of the pattern matching DSL is different from the examples we have seen earlier. We do not create a data structure that we can analyse nor do we evaluate expressions directly from expressions in our new language. Instead, we combine parsing expressions with code generation—we generate new functions and objects while we parse the specification. The functions and objects are added to the environment in which we call `:=`. This allows us to use the constructors after we have defined them with no further coding, but it does mean that calling `:=` will have side-effects.

The construction function will expect a type name as its left-hand-side parameter and an expression describing the different ways of constructing elements of the type on its right-hand side. We will translate the left-hand side into a quosure, because we want to get its associated environment, and the right-hand side into an expression. For the construction specification, we do not want to evaluate any of the elements (unless the user invokes quasi-quotations). The left-hand side—the type we are defining—is just treated as a string, since that is how the S3 system deals with types, so we will make sure that it is a single symbol and then get the string representation of it. For this, we can use the `quo_name` function from `rlang`. The right-hand side we have to parse, but we delegate this to a separate function that we define below. Finally, we define a function for pretty-printing elements of the new type we define.

```{r}
`:=` <- function(data_type, constructors) {
  data_type <- enquo(data_type)
  constructors <- enexpr(constructors)

  stopifnot(quo_is_symbol(data_type))
  data_type_name <- quo_name(data_type)
  process_alternatives(
    constructors, 
    data_type_name, 
    get_env(data_type)
  )

  assign(paste0("toString.", data_type_name),
         deparse_construction, envir = get_env(data_type))
  assign(paste0("print.", data_type_name),
         construction_printer, envir = get_env(data_type))
}
```

The last two statements in this function, the calls to `assign`, creates functions for printing elements of the type we are creating. We will implement the `deparse_construction` and `construction_printer` functions below. They extract information about values from meta-information we will store in objects of the new type and we can use the same functions for all types we define in our language. We use them to specialise the `toString` and `print` functions for this specific type. The `paste0` calls creates the names of the specialisations of the generic `toString` and `print` functions and the `assign` function then stores `deparse_construction` and `construction_printer` under the appropriate names in the environment we get from `get_env(data_type)`, i.e., the environment where we define the type.

The expression on the right-hand side of `:=` defines how we construct elements of the new type. We allow there to be more than one way to do this, and we separate the various choices using the or-operator `|`. This resembles how we show different alternatives when we specify a grammar, so it is a natural choice. To process the right-hand side, we use the function `process_alternatives`.

```{r}
process_alternatives <- function(constructors,
                                 data_type_name,
                                 env) {
  if (is_lang(constructors) && constructors[[1]] == "|") {
    process_alternatives(
      constructors[[2]],
      data_type_name,
      env
    )
    process_alternatives(
      constructors[[3]],
      data_type_name,
      env
    )
  } else {
    process_constructor(
      constructors,
      data_type_name,
      env
    )
  }
}
```

In addition to the constructor expression, we pass the name of the type and the environment we are defining it in as parameters. We do not use these directly in this function but merely pass them along. We will use them later, when we create the actual constructors.

The `process_alternatives` function recursively parse the expression to get all alternatives separated by `|`. The actual constructors will be either a function or a symbol, so the constructor specifications will not have higher precedence than the or-operator. The first time we see something that isn’t a call to `|`, then, we have a constructor. We handle those using the `process_constructor` function.

```{r}
process_constructor <- function(constructor, 
                                data_type_name,
                                env) {
  if (is_lang(constructor))
    process_constructor_function(
      constructor,
      data_type_name,
      env
    )
  else
    process_constructor_constant(
      constructor,
      data_type_name,
      env
    )
}
```

This function figures out if what we are looking at is a function constructor or a constant, i.e., a symbol. We use the `is_lang` function to test if we are looking at a function. It does the same as `is.call` from the `base` package; I just prefer the `rlang` functions for this chapter.

Constant constructors are the simplest. They are merely symbols so to make them available for programmers, we need to define a value for each such symbol. We will use `NA` as the value for these variables and store some meta-information with them. A class, so the `construction_printer` function will be called when we try to print the object, and the attribute `constructor_constant` that we will later need for pattern matching.

```{r}
process_constructor_constant <- function(constructor,
                                         data_type_name, 
                                         env) {
  stopifnot(is_symbol(constructor))
  constructor_name <- as_string(constructor)
  constructor_object <- structure(
    NA,
    constructor_constant = constructor_name,
    class = data_type_name
  )
  assign(constructor_name, constructor_object, envir = env)
}
```

For the function constructors we need to create, you guessed it, functions. We analyse the arguments given to the constructor specification and build a function out of that, and this function we then store in the environment where the constructor is defined. We permit two kinds of parameters to a constructor: either a symbol or a symbol with a type. For the latter, we use the `:` operator. If a parameter is a `:` call, then we consider the left-hand side the parameter and the right-hand side the type. We use the types to guarantee that values we construct are of the expected kind. If there is not type specified, we will allow a parameter to hold any value. We use the following function to translate the list of parameters from a function constructor expression into a data frame where the first column holds the argument names and the second column holds their type. We use `NA` to indicate that we allow any type. The function works by first translating the arguments—that are in the form of a `call` object—into a list. We have to use the base `as.list` function for this, rather than the `rlang` `as_list`, since the latter will not translate `call` objects into lists. Once we have the arguments as a list, we map the `process_arg` function over the elements. This function creates a row for the data frame per element, and we combine the rows using the `bind_rows` function from `dplyr`.

```{r}
process_arguments <- function(constructor_arguments) {
  process_arg <- function(argument) {
    if (is_lang(argument)) {
      stopifnot(argument[[1]] == ":")
      arg <- quo_name(argument[[2]])
      type <- quo_name(argument[[3]])
      tibble::tibble(arg = arg, type = type)
    } else {
      arg <- quo_name(argument)
      tibble::tibble(arg = arg, type = NA)
    }
  }
  constructor_arguments %>% 
    as.list %>% 
    purrr::map(process_arg) %>%   
    bind_rows
}
```

The `process_constructor_function` translates a function construction specification into a function. The first element of the specifications, which is a `call` object, is the name of the function. The remaining elements, we translate into a data frame using the function we just saw. After that, we need to create the function that will work as the constructor. Here, we create a closure without arguments and then add formal parameters afterwards, as we did in the previous chapter, and we get the actual parameters the closure is called with using the `as_list(environment())` trick.

The value we return from the closure is just the list of arguments that are provided to it, but tagged with a `constructor` attribute we can use for pattern matching and a `class` set to the type we are defining, something we use for type checking. The type checking is the main part of the constructor. Here, we check that we get the right number of arguments and that they have the right type if a type was specified.

Once we have created the closure and set its formal arguments we also update its class so it is both a `constructor` and a `function`. This is also something we will need when pattern matching. Then we assign it to the environment associated with the specification to make it available to the programmer.

```{r}
process_constructor_function <- function(constructor,
                                         data_type_name,
                                         env) {
  stopifnot(is_lang(constructor))
  constructor_name <- quo_name(constructor[[1]])
  constructor_arguments <- process_arguments(constructor[-1])

  # Create the constructor function
  constructor <- function() {
    args <- as_list(environment())

    # Type check!
    stopifnot(length(args) == length(constructor_arguments$arg))
    for (i in seq_along(args)) {
      arg <- args[[constructor_arguments$arg[i]]]
      type <- constructor_arguments$type[i]
      stopifnot(is_na(type) || inherits(arg, type))
    }

    structure(args,
              constructor = constructor_name,
              class = data_type_name)
  }
  formals(constructor) <- make_args_list(constructor_arguments$arg)

  # Set meta information about the constructor
  class(constructor) <- c("constructor", "function")

  # Put the constructor in the binding scope
  assign(constructor_name, constructor, envir = env)
}
```

The only remaining function to write for the constructors is the function for printing them. Here, we write a function that translate a constructed object into a string; this function we can then use recursively to translate any constructed element into a string. We then simply call this function in `construction_printer` which is the function that is assigned to the specialised `print` function for any type we define.

There is nothing complicated in the function. We first check if the object has an attribute “constructor”. Strictly speaking, only the function constructors have this—the constant constructors have the attribute “constructor_constant”, but the `attire` function will pick an attribute if it gets a unique prefix, so we also get that. If we do not have a “constructor” attribute, then it isn’t an element constructed from something we have defined from our language, so it must be a value of some other type—we just convert it into a string and return this. We use the generic `toString` function for this. This function converts any object into a string. Not necessarily a pretty representation of the object, but you can specialise it if you need to.

If the object we have *is* a constructor, it is either a constant or the result of a constructor function call. If the latter, it will be a list. If it is a list, then we must convert all the elements in the list into strings and paste them together. Otherwise, the name of the constructor is the string representation of the object.

```{r}
deparse_construction <- function(object) {
  constructor_name <- attr(object, "constructor")
  if (is_null(constructor_name)) {
    # This is not a constructor, so just get the value
    return(toString(object))
  }

  if (is_list(object)) {
    components <- names(object)
    values <- as_list(object) %>% purrr::map(deparse_construction)

    print_args <- vector("character", length = length(components))
    for (i in seq_along(components)) {
      print_args[i] <- paste0(components[i], "=", values[i])
    }
    print_args <- paste0(print_args, collapse = ", ")
    paste0(constructor_name, "(", print_args, ")")

  } else {
    constructor_name
  }
}
construction_printer <- function(x, ...) {
  cat(deparse_construction(x), "\\n")
}
```

As an example of using the construction language we can define a binary tree as either a tree with a left and right sub-tree or a leaf:

```{r}
tree := T(left : tree, right : tree) | L(value : numeric)
```

We can use the constructors to create a tree:

```{r}
x <- T(T(L(1),L(2)),L(3))
x
```

Values we create using these constructors can be accessed just as lists—which, in fact, they are—using the variable names we used in the type specification:

```{r}
x$left$left$value
x$left$right$value
x$right$value
```

The type checking is rather strict, however. We demand that the values we pass to the constructor functions are of the types we give in the specification—in the sense that they must inherit the class from the specification—and this can be a problem in some cases where R would otherwise normally just convert values. In the specification for the `L` constructor, for example, we require that the argument is `numeric`. We will get an error if we give it an `inter`:

```{r}
L(1L)
```

This is where we can use the variant of parameters without a type:

```{r}
tree := T(left : tree, right : tree) | L(value)
L(1L)
```

An alternative solution could be to specify more than one type in the specification. If you are interested, you can play with that. I will just leave it here and move on to pattern matching.

## Pattern matching

```{r}

test_pattern_rec <- function(escape, expr, test_expr, eval_env, match_env) {

  # Is this a function-constructor?
  if (is_lang(test_expr)) {
    func <- get(as_string(test_expr[[1]]), eval_env)
    if ("constructor" %in% class(func)) {
      # This is a constructor.
      # Check if it is the right kind
      constructor <- as_string(test_expr[[1]])
      expr_constructor <- attr(expr, "constructor")
      if (is_null(expr_constructor) || constructor != expr_constructor)
        escape(NULL) # wrong type

      # Now check recursively
      for (i in seq_along(expr)) {
        test_pattern_rec(escape, expr[[i]], test_expr[[i+1]], eval_env, match_env)
      }

      # If we get here, the matching was successfull
      return(match_env)
    }
  }

  # Is this a constant-constructor?
  if (is_symbol(test_expr) && exists(as_string(test_expr), eval_env)) {
    constructor <- as_string(test_expr)
    val <- get(constructor, eval_env)
    val_constructor <- attr(val, "constructor_constant")
    if (!is_null(val_constructor)) {
      expr_constructor <- attr(expr, "constructor")
      if (is_null(expr) || constructor != expr_constructor)
        escape(NULL) # wrong type
      else
        return(match_env) # Successfull match
    }
  }

  # Not a constructor.
  # Must be a value to compare with or a variable to bind to
  if (is_symbol(test_expr)) {
    assign(as_string(test_expr), expr, match_env)
  } else {
    value <- eval_tidy(test_expr, eval_env)
    if (expr != value) escape(NULL)
  }

  match_env
}

test_pattern <- function(expr, test_expr, eval_env) {
  # Environment in which to store matched variables
  match_env <- env()

  if (test_expr == quote(otherwise))
    return(match_env)

  # Test pattern
  tester <- function(escape)
    test_pattern_rec(escape, expr, test_expr, eval_env, match_env)
  callCC(tester)
}

match <- function(expr, ...) {
  matchings <- quos(...)
  matchings[[1]]

  for (i in seq_along(matchings)) {
    eval_env <- get_env(matchings[[i]])
    match_expr <- quo_expr(matchings[[i]])
    stopifnot(match_expr[[1]] == "<-")

    test_expr <- match_expr[[3]]
    result_expr <- match_expr[[2]]

    match <- test_pattern(expr, test_expr, eval_env)
    if (!is_null(match))
      return(eval_tidy(result_expr, data = match, env = eval_env))
  }

  stop("No matching pattern!")
}


tree := T(left : tree, right : tree) | L(value : numeric)

match(L(1),
      L(2) -> 12,
      L(1) -> 11,
      otherwise -> 13)


matching <- function(expr)
  match(expr,
        L(v) -> v,
        T(L(v), L(w)) -> v + w,
        otherwise -> 5)

matching(L(1))
matching(T(L(4), L(5)))
matching(T(L(1), T(L(4), L(5))))

dfs <- function(tree) {
  match(tree,
        L(v) -> v,
        T(left, right) -> dfs(left) + dfs(right))
}

dfs(L(1))
dfs(T(L(1),L(2)))

x <- T(T(L(1),L(2)),L(3))
dfs(x)
```

## Lists

```{r}

linked_list := NIL | CONS(car, cdr : linked_list)

reverse_list <- function(lst, acc = NIL) {
  force(acc)
  match(lst,
        NIL -> acc,
        CONS(car, cdr) -> reverse_list(cdr, CONS(car, acc)))
}

list_length <- function(lst, acc = 0) {
  force(acc)
  match(lst,
        NIL -> acc,
        CONS(car, cdr) -> list_length(cdr, acc + 1))
}

list_to_vector <- function(lst) {
  n <- list_length(lst)
  v <- vector("list", length = n)
  f <- function(lst, i) {
    force(i)
    match(lst,
          NIL -> NULL,
          CONS(car, cdr) -> {
            v[[i]] <<- car
            f(cdr, i + 1)
            }
          )
  }
  f(lst, 1)
  v %>% unlist
}

vector_to_list <- function(vec) {
  lst <- NIL
  for (i in seq_along(vec)) {
    lst <- CONS(vec[[i]], lst)
  }
  reverse_list(lst)
}

lst <- vector_to_list(1:5)
list_length(lst)
list_to_vector(lst)
lst %>% reverse_list %>% list_to_vector
```

## Search trees

```{r}
search_tree := E | T(left : search_tree, value, right : search_tree)

insert <- function(tree, x) {
  match(tree,
        E -> T(E, x, E),
        T(left, val, right) ->
          if (x < val)
            T(insert(left, x), val, right)
          else if (x > val)
            T(left, val, insert(right, x))
          else
            T(left, x, right)
        )
}

member <- function(tree, x) {
  match(tree,
        E -> FALSE,
        T(left, val, right) -> {
          if (x < val) member(left, x)
          else if (x > val) member(right, x)
          else TRUE
        })
}

tree <- E
for (i in sample(2:4))
  tree <- insert(tree, i)

for (i in 1:6) {
  cat(i, " : ", member(tree, i), "\\n")
}
```

```{r}
colour := R | B
rb_tree := E | T(col : colour, left : rb_tree, value, right : rb_tree)


member <- function(tree, x) {
  match(tree,
        E -> FALSE,
        T(col, left, val, right) -> {
          if (x < val) member(left, x)
          else if (x > val) member(right, x)
          else TRUE
        })
}

tree <- T(R, E, 2, T(B, E, 5, E))
for (i in 1:6) {
  cat(i, " : ", member(tree, i), "\\n")
}

insert_rec <- function(tree, x) {
  match(tree,
        E -> T(R, E, x, E),
        T(col, left, val, right) -> {
          if (x < val)
            balance(T(col, insert_rec(left, x), val, right))
          else if (x > val)
            balance(T(col, left, val, insert_rec(right, x)))
          else
            T(col, left, x, right) # already here
        })
}
insert <- function(tree, x) {
  tree <- insert_rec(tree, x)
  tree$col <- B
  tree
}

balance <- function(tree) {
  match(tree,
        T(B,T(R,a,x,T(R,b,y,c)),z,d) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,T(R,T(R,a,x,b),y,c),z,d) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,a,x,T(R,b,y,T(R,c,z,d))) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,a,x,T(R,T(R,b,y,c),z,d)) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        otherwise -> tree)
}

tree <- E
for (i in sample(2:4))
  tree <- insert(tree, i)
for (i in 1:6) {
  cat(i, " : ", member(tree, i), "\\n")
}

tree <- T(B, T(R, E, 0, T(R, E, 1, E)), 2, E)
balance(tree)
```
