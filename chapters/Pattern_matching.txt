# Pattern matching

In languages such as ML or Haskell, you can define data types by specifying functions you will use to construct values of any given type. In itself, that is not that interesting, but combined with a pattern matching feature of these languages, you can write very succinct functions for transforming data structures.

In my book on *Functional Data Structures in R* [@Mailund:2017ul], I describe several algorithms that depend on transformation of various trees based on their structure. This involves figuring out the current structure of a tree—does it have a left sub-tree? Is that tree a leaf? If it is a red-black search tree, what is the colour of the tree? And the colour of its right sub-tree? In the algorithms I presented in that book, most of the functions contained tens of lines of code just for matching such tree structure.

With the language we implement in this chapter, we will make writing such transformation functions vastly more efficient. We will write two main constructions. The first for defining a data structure, which we can use to define red-black search trees like this:

```r
colour := R | B
rb_tree := E | T(col : colour, left : rb_tree, value, right : rb_tree)
```

The second constructing is used to match values of such types and then perform actions accordingly. A balancing function for red-black search trees can be succinctly implemented like this:

```r
balance <- function(tree) {
  match(tree,
        T(B,T(R,a,x,T(R,b,y,c)),z,d) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,T(R,T(R,a,x,b),y,c),z,d) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,a,x,T(R,b,y,T(R,c,z,d))) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,a,x,T(R,T(R,b,y,c),z,d)) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        otherwise -> tree)
}
```

This function is mere eight lines, compared to the 42 lines of code used in *Functional Data Structures in R*, where I also use some pattern matching tricks but not a domain-specific language especially designed for it. Such a language is what we will implement in this chapter.

For the chapter, we need to will use the following packages:

```r
library(rlang)
library(magrittr)
library(dplyr)
```

We will also need the `make_args_list` function we defined in [Chapter @sec:lambda].

```{r}
make_args_list <- function(args) {
  res <- replicate(length(args), substitute())
  names(res) <- args
  as.pairlist(res)
}
```

## Constructors

The first construction we must implement is for defining data types. Here, we will use the `:=` operator. Assignment has the lowest precedence, which means that whatever we write to the left or right of this operator will be arguments to the function. We do not have to worry about an expression in our language being translated into some `call` object of a different type. We cannot override the other assignment operators, `<-`, `->` and `=`, so we have to use `:=`. Since this is also traditionally used to mean “defined to be equal to”, it works quite well.

The approach we take in implementing this part of the pattern matching DSL is different from the examples we have seen earlier. We do not create a data structure that we can analyse nor do we evaluate expressions directly from expressions in our new language. Instead, we combine parsing expressions with code generation—we generate new functions and objects while we parse the specification. The functions and objects are added to the environment in which we call `:=`. This allows us to use the constructors after we have defined them with no further coding, but it does mean that calling `:=` will have side-effects.

The construction function will expect a type name as its left-hand-side parameter and an expression describing the different ways of constructing elements of the type on its right-hand side. We will translate the left-hand side into a quosure, because we want to get its associated environment, and the right-hand side into an expression. For the construction specification, we do not want to evaluate any of the elements (unless the user invokes quasi-quotations). The left-hand side—the type we are defining—is just treated as a string, since that is how the S3 system deals with types, so we will make sure that it is a single symbol and then get the string representation of it. For this, we can use the `quo_name` function from `rlang`. The right-hand side we have to parse, but we delegate this to a separate function that we define below. Finally, we define a function for pretty-printing elements of the new type we define.

```{r}
`:=` <- function(data_type, constructors) {
  data_type <- enquo(data_type)
  constructors <- enexpr(constructors)

  stopifnot(quo_is_symbol(data_type))
  data_type_name <- quo_name(data_type)
  process_alternatives(
    constructors, 
    data_type_name, 
    get_env(data_type)
  )

  assign(paste0("print.", data_type_name),
         construction_printer, envir = get_env(data_type))
}
```

The last statement in this function, the call to `assign`, creates a function for printing elements of the type we are creating. The `construction_printer` function is a function that we define below. It extracts information about values from meta-information we will store in objects of the new type and we can use the same function for all types we define in our language. We use it to specialise the `print` function for this specific type. The `paste0("print.", data_type_name)` call creates the name of the specialisation of the generic `print` and the `assign` function then stores `construction_printer` under that name in the environment we get from `get_env(data_type)`, i.e., the environment where we define the type.

The expression on the right-hand side of `:=` defines how we construct elements of the new type. We allow there to be more than one way to do this, and we separate the various choices using the or-operator `|`. This resembles how we show different alternatives when we specify a grammar, so it is a natural choice. To process the right-hand side, we use the function `process_alternatives`.

```{r}
process_alternatives <- function(constructors,
                                 data_type_name,
                                 env) {
  if (is_lang(constructors) && constructors[[1]] == "|") {
    process_alternatives(
      constructors[[2]],
      data_type_name,
      env
    )
    process_alternatives(
      constructors[[3]],
      data_type_name,
      env
    )
  } else {
    process_constructor(
      constructors,
      data_type_name,
      env
    )
  }
}
```

In addition to the constructor expression, we pass the name of the type and the environment we are defining it in as parameters. We do not use these directly in this function but merely pass them along. We will use them later, when we create the actual constructors.

The `process_alternatives` function recursively parse the expression to get all alternatives separated by `|`. The actual constructors will be either a function or a symbol, so the constructor specifications will not have higher precedence than the or-operator. The first time we see something that isn’t a call to `|`, then, we have a constructor. We handle those using the `process_constructor` function.

```{r}
process_constructor <- function(constructor, 
                                data_type_name,
                                env) {
  if (is_lang(constructor))
    process_constructor_function(
      constructor,
      data_type_name,
      env
    )
  else
    process_constructor_constant(
      constructor,
      data_type_name,
      env
    )
}
```

This function figures out if what we are looking at is a function constructor or a constant, i.e., a symbol. We use the `is_lang` function to test if we are looking at a function. It does the same as `is.call` from the `base` package; I just prefer the `rlang` functions for this chapter.

Constant constructors are the simplest. They are merely symbols so to make them available for programmers, we need to define a value for each such symbol. We will use `NA` as the value for these variables and store some meta-information with them. A class, so the `construction_printer` function will be called when we try to print the object, and the attribute `constructor_constant` that we will later need for pattern matching.

```{r}
process_constructor_constant <- function(constructor,
                                         data_type_name, 
                                         env) {
  stopifnot(is_symbol(constructor))
  constructor_name <- as_string(constructor)
  constructor_object <- structure(
    NA,
    constructor_constant = constructor_name,
    class = data_type_name
  )
  assign(constructor_name, constructor_object, envir = env)
}
```



```{r}
process_arguments <- function(constructor_arguments) {
  process_arg <- function(argument) {
    if (is_lang(argument)) {
      stopifnot(argument[[1]] == ":")
      arg <- quo_name(argument[[2]])
      type <- quo_name(argument[[3]])
      tibble::tibble(arg = arg, type = type)
    } else {
      arg <- quo_name(argument)
      tibble::tibble(arg = arg, type = "any")
    }
  }
  constructor_arguments %>% as.list %>% purrr::map(process_arg) %>% bind_rows
}

process_constructor_function <- function(constructor, data_type_name, env) {
  stopifnot(is.call(constructor))

  constructor_name <- quo_name(constructor[[1]])
  constructor_arguments <- process_arguments(constructor[-1])

  # create the constructor function
  constructor <- function() {
    args <- as_list(environment())

    # type check!
    stopifnot(length(args) == length(constructor_arguments$arg))
    for (i in seq_along(args)) {
      arg <- args[[constructor_arguments$arg[i]]]
      type <- constructor_arguments$type[i]
      stopifnot(type == "any" || type %in% class(arg))
    }

    structure(args,
              constructor = constructor_name,
              class = data_type_name)
  }
  formals(constructor) <- make_args_list(constructor_arguments$arg)

  # set meta information about the constructor
  class(constructor) <- c("constructor", "function")

  # put the constructor in the binding scope
  assign(constructor_name, constructor, envir = env)
}
```

```{r}
deparse_construction <- function(object) {
  constructor_name <- attr(object, "constructor")
  if (is_null(constructor_name)) {
    # this is not a constructor, so just get the value
    return(as.character(object))
  }

  if (is_list(object)) {
    components <- names(object)
    values <- as_list(object) %>% purrr::map(deparse_construction)

    print_args <- vector("character", length = length(components))
    for (i in seq_along(components)) {
      print_args[i] <- paste0(components[i], " = ", values[i])
    }
    print_args <- paste0(print_args, collapse = ", ")
    paste0(constructor_name, "(", print_args, ")")

  } else {
    constructor_name
  }
}
construction_printer <- function(x, ...) {
  cat(deparse_construction(x), "\\n")
}
```

```{r}
tree := T(left : tree, right : tree) | L(value : numeric)

x <- T(T(L(1),L(2)),L(3))
x

x$left$left$value
x$left$right$value
x$right$value
```

```{r}
L(1L)
```

```{r}
tree := T(left : tree, right : tree) | L(value)
L(1L)
```

## Pattern matching

```{r}

test_pattern_rec <- function(escape, expr, test_expr, eval_env, match_env) {

  # Is this a function-constructor?
  if (is_lang(test_expr)) {
    func <- get(as_string(test_expr[[1]]), eval_env)
    if ("constructor" %in% class(func)) {
      # This is a constructor.
      # Check if it is the right kind
      constructor <- as_string(test_expr[[1]])
      expr_constructor <- attr(expr, "constructor")
      if (is_null(expr_constructor) || constructor != expr_constructor)
        escape(NULL) # wrong type

      # Now check recursively
      for (i in seq_along(expr)) {
        test_pattern_rec(escape, expr[[i]], test_expr[[i+1]], eval_env, match_env)
      }

      # If we get here, the matching was successfull
      return(match_env)
    }
  }

  # Is this a constant-constructor?
  if (is_symbol(test_expr) && exists(as_string(test_expr), eval_env)) {
    constructor <- as_string(test_expr)
    val <- get(constructor, eval_env)
    val_constructor <- attr(val, "constructor_constant")
    if (!is_null(val_constructor)) {
      expr_constructor <- attr(expr, "constructor")
      if (is_null(expr) || constructor != expr_constructor)
        escape(NULL) # wrong type
      else
        return(match_env) # Successfull match
    }
  }

  # Not a constructor.
  # Must be a value to compare with or a variable to bind to
  if (is_symbol(test_expr)) {
    assign(as_string(test_expr), expr, match_env)
  } else {
    value <- eval_tidy(test_expr, eval_env)
    if (expr != value) escape(NULL)
  }

  match_env
}

test_pattern <- function(expr, test_expr, eval_env) {
  # Environment in which to store matched variables
  match_env <- env()

  if (test_expr == quote(otherwise))
    return(match_env)

  # Test pattern
  tester <- function(escape)
    test_pattern_rec(escape, expr, test_expr, eval_env, match_env)
  callCC(tester)
}

match <- function(expr, ...) {
  matchings <- quos(...)
  matchings[[1]]

  for (i in seq_along(matchings)) {
    eval_env <- get_env(matchings[[i]])
    match_expr <- quo_expr(matchings[[i]])
    stopifnot(match_expr[[1]] == "<-")

    test_expr <- match_expr[[3]]
    result_expr <- match_expr[[2]]

    match <- test_pattern(expr, test_expr, eval_env)
    if (!is_null(match))
      return(eval_tidy(result_expr, data = match, env = eval_env))
  }

  stop("No matching pattern!")
}


tree := T(left : tree, right : tree) | L(value : numeric)

match(L(1),
      L(2) -> 12,
      L(1) -> 11,
      otherwise -> 13)


matching <- function(expr)
  match(expr,
        L(v) -> v,
        T(L(v), L(w)) -> v + w,
        otherwise -> 5)

matching(L(1))
matching(T(L(4), L(5)))
matching(T(L(1), T(L(4), L(5))))

dfs <- function(tree) {
  match(tree,
        L(v) -> v,
        T(left, right) -> dfs(left) + dfs(right))
}

dfs(L(1))
dfs(T(L(1),L(2)))

x <- T(T(L(1),L(2)),L(3))
dfs(x)
```

## Lists

```{r}

linked_list := NIL | CONS(car, cdr : linked_list)

reverse_list <- function(lst, acc = NIL) {
  force(acc)
  match(lst,
        NIL -> acc,
        CONS(car, cdr) -> reverse_list(cdr, CONS(car, acc)))
}

list_length <- function(lst, acc = 0) {
  force(acc)
  match(lst,
        NIL -> acc,
        CONS(car, cdr) -> list_length(cdr, acc + 1))
}

list_to_vector <- function(lst) {
  n <- list_length(lst)
  v <- vector("list", length = n)
  f <- function(lst, i) {
    force(i)
    match(lst,
          NIL -> NULL,
          CONS(car, cdr) -> {
            v[[i]] <<- car
            f(cdr, i + 1)
            }
          )
  }
  f(lst, 1)
  v %>% unlist
}

vector_to_list <- function(vec) {
  lst <- NIL
  for (i in seq_along(vec)) {
    lst <- CONS(vec[[i]], lst)
  }
  reverse_list(lst)
}

lst <- vector_to_list(1:5)
list_length(lst)
list_to_vector(lst)
lst %>% reverse_list %>% list_to_vector
```

## Search trees

```{r}
search_tree := E | T(left : search_tree, value, right : search_tree)

insert <- function(tree, x) {
  match(tree,
        E -> T(E, x, E),
        T(left, val, right) ->
          if (x < val)
            T(insert(left, x), val, right)
          else if (x > val)
            T(left, val, insert(right, x))
          else
            T(left, x, right)
        )
}

member <- function(tree, x) {
  match(tree,
        E -> FALSE,
        T(left, val, right) -> {
          if (x < val) member(left, x)
          else if (x > val) member(right, x)
          else TRUE
        })
}

tree <- E
for (i in sample(2:4))
  tree <- insert(tree, i)

for (i in 1:6) {
  cat(i, " : ", member(tree, i), "\\n")
}
```

```{r}
colour := R | B
rb_tree := E | T(col : colour, left : rb_tree, value, right : rb_tree)


member <- function(tree, x) {
  match(tree,
        E -> FALSE,
        T(col, left, val, right) -> {
          if (x < val) member(left, x)
          else if (x > val) member(right, x)
          else TRUE
        })
}

tree <- T(R, E, 2, T(B, E, 5, E))
for (i in 1:6) {
  cat(i, " : ", member(tree, i), "\n")
}

insert_rec <- function(tree, x) {
  match(tree,
        E -> T(R, E, x, E),
        T(col, left, val, right) -> {
          if (x < val)
            balance(T(col, insert_rec(left, x), val, right))
          else if (x > val)
            balance(T(col, left, val, insert_rec(right, x)))
          else
            T(col, left, x, right) # already here
        })
}
insert <- function(tree, x) {
  tree <- insert_rec(tree, x)
  tree$col <- B
  tree
}

balance <- function(tree) {
  match(tree,
        T(B,T(R,a,x,T(R,b,y,c)),z,d) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,T(R,T(R,a,x,b),y,c),z,d) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,a,x,T(R,b,y,T(R,c,z,d))) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        T(B,a,x,T(R,T(R,b,y,c),z,d)) -> T(R,T(B,a,x,b),y,T(B,c,z,d)),
        otherwise -> tree)
}

tree <- E
for (i in sample(2:4))
  tree <- insert(tree, i)
for (i in 1:6) {
  cat(i, " : ", member(tree, i), "\\n")
}

tree <- T(B, T(R, E, 0, T(R, E, 1, E)), 2, E)
balance(tree)
```
