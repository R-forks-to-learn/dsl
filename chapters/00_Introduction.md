
# Introduction

This book gives an introduction to embedded domain specific languages in R. The term *domain specific languages,* or DSL, refers to programming languages specialised for a given purpose, as opposed to general purpose programming languages. Domain specific languages ideally give you a precise way of specifying tasks you want to do and goals you want to achieve within a specialised context. Regular expressions is one example, where you have a specialised language to express patterns of text. You can use this domain specific language to define text strings to search for or specify rules for modifying text. Regular expressions are often considered very hard to read, but they do provide a very powerful language for describing text patterns. Another example of a domain specific language is SQL---a language specialised for extracting from and modifying in a relational data base. With SQL, you have a powerful domain specific language in which you can specify rules for which data points in a data base you want to access or modify.

Regular expressions and SQL expressions are typically specified as strings when you use them in a program, and these strings must be parsed and interpreted when your program runs. In a sense, they are languages separated from the programming language you use them *in*. They need to separately be compiled and used by a different compiler or interpreter. In contrast, *embedded* domain specific languages provide domain specific languages expressed in the general purpose language in which they are used. In R, the grammar of graphics implemented in `ggplot2` or the data transformation operations implemented in `dplyr` provide small languages---domain specific languages---that you can use from within R, and you write the programs for these languages in R as well.

Embedded DSLs extend the programming language you are working in. They provide more than you usually find in a framework in the form of functions and classes as they provide a high level of flexibility in what you can do with them. They are programming languages, after all, and you can express complex ideas and tasks in them. They provide a language for expressing thoughts in a specialised domain, so they do not provide a general programming language as the language you use them from, but they do extend that surrounding language with new expressive power. Being embedded in that language, however, they will follow the rules you are familiar with there. Or mostly, at least, since in languages such as R, it is possible to modify the rules a bit programatically. You can expect the syntax of the embedded DSL to follow the rules of the general purpose language. The semantics will be determined by the DSL, but when you write programs in the DSL the syntax is already familiar to you. If you implement a DSL yourself, embedding it in a general purpose language lets you reuse the parsing and evaluation done by the general purpose language, so you can focus on just the domain specific part of the language.

Implementing embedded domain specific languages involves *meta programming*, that is, it involves treating the program you are writing as data to be manipulated by the program itself. This might sound more complicated than it is, but quite often, it is fairly straightforward to achieve. You *can* use meta programming to manipulate expressions in R and modify them and change how they are evaluated---and we will see examples in this book---but you can also construct expressive languages just from combining traditional functions and operator overloading.




